---
title: 検証器とJITコンパイラ
tags:
    - [Linux]
    - [Kernel]
    - [BPF]
    - [JIT]
lang: ja

pagination: true
fd: verifier.html
bk: jit_bug.html
---
LK06(Brahman)では、Linuxカーネルの機能の1つである、eBPFに含まれるJITのバグを攻撃します。この章では、まずBPFという機能と、その使い方について学びます。

<div class="column" title="目次">
<!-- toc --><br>
</div>

## 検証器
まずは、eBPFの検証器について学びましょう。検証器のソースコードはLinuxカーネルの[`kernel/bpf/verifier.c`](https://elixir.bootlin.com/linux/v5.18.11/source/kernel/bpf/verifier.c)に書かれています。。
検証器は命令を1つずつチェックし、すべての分岐先をexit命令までトレースします。検証は大きく二段階（First Pass, Second Pass）に分けられます。

一段階目のチェックでは、深さ優先探索によってプログラムが有向非巡回グラフ（DAG; Directed Acyclic Graph）であることを保証します。DAGとはループを持たない有向グラフのことです。
このチェックにより、次のようなプログラムは拒否されます。

- `BPF_MAXINSNS`を超える命令が存在する場合
- ループフローが存在する場合
- 到達不可能な命令が存在する場合
- 範囲外、あるいは不正なジャンプが存在する場合

二段階目のチェックでは、あらためてすべてのパスを探索します。このとき、レジスタの値に対して型や範囲を追跡します。
このチェックにより、例えば次のようなプログラムは拒否されます。

- 未初期化レジスタの利用
- スタックやMAPへのポインタのreturn
- 不正なポインタの読み書き

### 一段階目のチェック


### 二段階目のチェック
二段階目のチェックではレジスタに型をつけ、また定数の範囲を追跡します。

#### 定数の追跡
検証器ではレジスタの定数を追跡しています。値は区間を使った抽象化で追跡されます。つまり、各レジスタについて、その時点でレジスタが取り得る「最小値」と「最大値」を記録しています。




<div class="balloon_l">
  <div class="faceicon"><img src="../img/wolf_atamawaru.png" alt="オオカミくん" ></div>
  <p class="says">
    具体的な値が分からない解析過程では、値を抽象的な範囲で推測することが多いね。
    健全（sound）な手法で抽象化しないと、解釈結果が間違うことがあるよ。
  </p>
</div>



#### 型の変化
検証器はレジスタの値がどのような種類の値かを保持しています。例えば次のような命令を考えましょう。
```
BPF_MOV64_REG(BPF_REG_0, BPF_REG_10)
BPF_ALU64_IMM(BPF_ADD, BPF_REG_0, -8)
```
最初の命令ではスタックポインタを`R0`に代入しています。このとき、`R0`は`FRAME_PTR`という型になります。次の命令では`R0`から8だけ引かれますが、まだスタックの範囲内を指しているため、`PTR_TO_STACK`となります。
他にもポインタとポインタの足し算は定数扱いになったり、命令の種類とレジスタの型、値の範囲などに応じて、新しい型は変わります。


## JIT

